import json
import typing
import settings
import operator
import sqlalchemy
from sqlalchemy.schema import CreateColumn
from sqlalchemy.ext.compiler import compiles
from datetime import datetime
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy_utils import database_exists, create_database, drop_database
import attridict

DATABASE_CONNECTION_URL = settings.DATABASE_URL

if settings.DROP_DATABASE_ON_STARTUP:
    drop_database(DATABASE_CONNECTION_URL)

if not database_exists(DATABASE_CONNECTION_URL):
    create_database(DATABASE_CONNECTION_URL)

engine = sqlalchemy.create_engine(DATABASE_CONNECTION_URL)
session = sqlalchemy.orm.Session(bind=engine)

FILTER_QUERIES = {
    'in': operator.contains,
    'contains': operator.contains,
    'eq': operator.eq,
    'gt': operator.gt,
    'gte': operator.ge,
    'lte': operator.le,
    'lt': operator.lt,
    'is_not': operator.is_not,
    'and': operator.and_,
    'or': operator.or_,
    'index': operator.indexOf,
}


class AttributeDict(dict):
    def __getattr__(self, item):
        return self[item]


@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace("SERIAL", "INT GENERATED BY DEFAULT AS IDENTITY")
    return text


def get_current_time():
    return datetime.now()


class SqlAlchemyModel(DeclarativeBase):
    """
    Базовая модель СУБД проекта
    """

    id = sqlalchemy.Column(
        sqlalchemy.BigInteger(),
        sqlalchemy.Identity(start=1, cycle=False),
        primary_key=True
    )

    def as_dict(self):
        instance_dict = self.__dict__.copy()
        instance_dict.pop('_sa_instance_state')

        return attridict.AttriDict(instance_dict)

    def __str__(self):
        return json.dumps(self.as_dict())

    def __repr__(self):
        return json.dumps(self.as_dict())

    def __json__(self):
        return self.as_dict()

    @classmethod
    def filter_field(cls, key, value):
        default_filter_name = 'eq'

        if key.count('__') > 1:
            raise RuntimeError(
                'Указано больше параметров, чем нужно'
            )

        if '__' not in key:
            filter_name = default_filter_name
        else:
            filter_input = key.split('__')
            filter_name = filter_input[-1]
            key = filter_input[0]

        if filter_name not in FILTER_QUERIES:
            raise RuntimeError(
                f'Фильтра "__{filter_name}" не существует.'
            )

        filter_func = FILTER_QUERIES[filter_name]
        return filter_func(getattr(cls, key), value)

    @classmethod
    def convert_kwargs(cls, **kwargs):
        new_filters = []

        for key, value in kwargs.items():
            new_filters.append(
                cls.filter_field(key, value)
            )

        return new_filters

    @classmethod
    def decompile_filters(cls, **filters):
        result = {}

        for key, val in filters.items():
            if '__' not in key:
                result[key] = val

            else:
                result[key.split('__')[0]] = val

        return result

    @classmethod
    def fetch_one(cls, *filters: typing.Callable, **kwargs: [str, typing.Any]) -> typing.Self:
        kwargs_filters = cls.convert_kwargs(**kwargs)

        query = session.execute(
            sqlalchemy.select(cls).where(*filters, *kwargs_filters).limit(1)
        )

        response = query.unique().fetchone()
        if not response:
            return None

        return response[0].as_dict()

    @classmethod
    def fetch_all(cls, *filters: typing.Callable, **kwargs: [str, typing.Any]) -> typing.List[typing.Self]:
        kwargs_filters = cls.convert_kwargs(**kwargs)

        query = session.execute(
            sqlalchemy.select(cls).where(*filters, *kwargs_filters)
        )

        result = query.unique().fetchall()
        return [row[0].as_dict() for row in result]

    @classmethod
    def create(cls, **kwargs) -> typing.Self:
        if 'id' in kwargs:
            kwargs.pop('id')

        session.execute(
            sqlalchemy.insert(cls).values(**kwargs)
        )

        session.commit()
        return cls.fetch_one(**kwargs)

    @classmethod
    def fetch_or_create(cls, **kwargs: [str, typing.Any]) -> [typing.Self, bool]:
        data = cls.fetch_one(**kwargs)

        if not data:
            kwargs_decompiled = cls.decompile_filters(**kwargs)
            return [cls.create(**kwargs_decompiled), True]

        return [data, False]

    @classmethod
    def delete(cls,  *filters: typing.Callable, **kwargs: [str, typing.Any]) -> None:
        kwargs_filters = cls.convert_kwargs(**kwargs)

        session.execute(
            sqlalchemy.delete(cls).where(*filters, *kwargs_filters)
        )

        return session.commit()

    @classmethod
    def update(cls, row_id: int, **kwargs) -> typing.Self:
        filter_query = cls.convert_kwargs(id=row_id)

        query = session.execute(
            sqlalchemy.update(cls).where(*filter_query).values(**kwargs)
        )

        session.commit()
        return cls.fetch_one(id=query.lastrowid)


class Subject(SqlAlchemyModel):
    """
    Модель школьного предмета
    """

    __tablename__ = 'subjects'

    title = sqlalchemy.Column(
        sqlalchemy.VARCHAR(256),
        nullable=False
    )


class Task(SqlAlchemyModel):
    """
    Модель задания части учебника
    """

    __tablename__ = 'tasks'

    title = sqlalchemy.Column(
        sqlalchemy.VARCHAR(255),
        nullable=False
    )

    description = sqlalchemy.Column(
        sqlalchemy.Text(),
        nullable=True
    )

    part_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey(
            'parts.id',
            ondelete='CASCADE',
            onupdate='CASCADE'
        ),
        nullable=False
    )

    part = sqlalchemy.orm.relationship(
        'Part',
        backref=sqlalchemy.orm.backref('tasks', lazy='immediate')
    )


class TaskImage(SqlAlchemyModel):
    """
    Модель изображения учебника
    """

    __tablename__ = 'images'

    url = sqlalchemy.Column(
        sqlalchemy.Text(),
        nullable=False
    )

    task_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey('tasks.id'),
        nullable=False
    )

    task = sqlalchemy.orm.relationship(
        'Task',
        backref=sqlalchemy.orm.backref('images', lazy='immediate')
    )


class Part(SqlAlchemyModel):
    """
    Модель для части учебника
    """

    __tablename__ = 'parts'

    title = sqlalchemy.Column(
        sqlalchemy.VARCHAR(100),
        nullable=False
    )

    book_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey(
            'books.id',
            ondelete="CASCADE",
            onupdate="CASCADE"
        ),
        nullable=False
    )

    book = sqlalchemy.orm.relationship(
        'Book',
        backref=sqlalchemy.orm.backref('parts', lazy='immediate')
    )


class Book(SqlAlchemyModel):
    """
    Модель книги
    """

    __tablename__ = 'books'

    title = sqlalchemy.Column(
        sqlalchemy.VARCHAR(256),
        nullable=False,
    )

    year = sqlalchemy.Column(
        sqlalchemy.VARCHAR(50),
        nullable=True
    )

    classes = sqlalchemy.Column(
        sqlalchemy.ARRAY(
            sqlalchemy.Integer(),
            as_tuple=True
        ),
        nullable=False
    )

    authors = sqlalchemy.Column(
        sqlalchemy.ARRAY(
            sqlalchemy.VARCHAR(100),
            as_tuple=True
        ),
        nullable=False
    )

    description = sqlalchemy.Column(
        sqlalchemy.Text(),
    )

    publisher = sqlalchemy.Column(
        sqlalchemy.VARCHAR(100),
        nullable=False
    )

    subtype = sqlalchemy.Column(
        sqlalchemy.VARCHAR(100),
        nullable=True
    )

    cover_url = sqlalchemy.Column(
        sqlalchemy.Text(),
        nullable=True
    )

    search_keywords = sqlalchemy.Column(
        sqlalchemy.Text(),
        nullable=True
    )

    updated_at = sqlalchemy.Column(
        sqlalchemy.DateTime(timezone=False),
        nullable=True
    )

    subject_id = sqlalchemy.Column(
        sqlalchemy.ForeignKey(
            'subjects.id',
            ondelete='CASCADE',
            onupdate='CASCADE'
        ),
        nullable=False
    )

    subject = sqlalchemy.orm.relationship(
        'Subject',
        lazy='immediate',
    )


SqlAlchemyModel.metadata.create_all(bind=engine)
